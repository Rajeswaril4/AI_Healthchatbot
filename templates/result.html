{% extends "base.html" %}
{% block title %}Diagnosis Result | AI HealthBot{% endblock %}

{% block content %}
  <div class="result-card" role="region" aria-labelledby="disease-heading">
    <h1 id="disease-heading" class="disease-name">üß¨ {{ result.disease }}</h1>

    <div class="meta-row">
      <div class="meta-item">
        <div class="section-title"><i class="fas fa-user-md"></i> Specialist</div>
        <p class="specialist">{{ result.doctor_specialty }}</p>
      </div>

      <div class="meta-item">
        <div class="section-title"><i class="fas fa-calendar-check"></i> Confidence</div>
        <p class="specialist">Model confidence: <strong>{{ result.confidence or 'N/A' }}</strong></p>
        <div class="confidence-meter" aria-hidden="true" style="margin-top:8px;">
          <div class="confidence-fill" data-conf="{{ result.conf_num or '' }}"></div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title"><i class="fas fa-list"></i> Selected Symptoms</div>
      {% if result.selected_symptoms %}
        <div class="selected-symptoms" aria-live="polite">
          {% for s in result.selected_symptoms %}
            <span class="selected-symptom">{{ s.replace('_',' ') | title }}</span>
          {% endfor %}
        </div>
      {% else %}
        <p class="text-muted">No symptoms were selected.</p>
      {% endif %}
    </div>

    <div class="section">
      <div class="section-title"><i class="fas fa-notes-medical"></i> Brief Description</div>
      <p class="description">{{ result.description }}</p>
    </div>

    <div class="section">
      <div class="section-title"><i class="fas fa-shield-alt"></i> Recommended Precautions</div>
      <ul class="precautions">
        {% for p in result.precautions %}
          <li>{{ p }}</li>
        {% endfor %}
      </ul>
    </div>

    <div class="actions" style="margin-bottom:18px;">
      <a href="{{ url_for('index') }}" class="btn btn-primary" aria-label="Go back and change symptoms">üîÅ Go Back</a>
      <a href="#" id="print-btn" class="btn btn-outline" onclick="window.print();return false;" aria-label="Save result as PDF">üñ®Ô∏è Save as PDF</a>
      {% if current_user.is_authenticated %}
        <a href="{{ url_for('history') }}" class="btn btn-outline">View History</a>
      {% endif %}
    </div>

    <!-- Nearby specialists UI -->
    <div class="section" aria-labelledby="nearby-heading">
      <div class="section-title" id="nearby-heading"><i class="fas fa-map-marker-alt"></i> Nearby {{ result.doctor_specialty }}</div>

      <div id="nearby-actions" style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">
        <button id="find-nearby" class="btn btn-primary" type="button">Show nearby {{ result.doctor_specialty }}</button>
        <small id="nearby-msg" style="color:#666;">Allow location access when prompted. The app will try to obtain your location automatically.</small>
      </div>

      <div id="map" style="height:360px;border-radius:8px;display:none;margin-bottom:12px;" role="region" aria-label="Map showing nearby clinics"></div>

      <div style="display:flex;gap:16px;align-items:flex-start;">
        <ul id="nearby-list" class="precautions" style="flex:1;max-height:360px;overflow:auto;padding:12px;border-radius:8px;background:var(--card-background);">
          <!-- items injected by JS -->
        </ul>

        <div id="nearby-fallback" style="width:280px;display:none;">
          <label for="fallback-location" class="sr-only">Enter place</label>
          <input id="fallback-location" class="text-input" placeholder="Enter city or pincode (e.g. Chennai, 600xxx)" aria-label="Enter city or pincode">
          <button id="fallback-search" class="btn btn-outline" style="margin-top:8px;">Search</button>
          <p class="text-muted" style="margin-top:8px;font-size:13px;">If you deny location access, use this to search by place name or pincode.</p>
        </div>
      </div>
    </div>
  </div>

  {# Leaflet: use local static copies to avoid third-party tracking/prevention issues #}
  <link rel="stylesheet" href="{{ url_for('static', filename='vendor/leaflet/leaflet.css') }}">
  <script src="{{ url_for('static', filename='vendor/leaflet/leaflet.js') }}"></script>

  <script>
    // Ensure default marker icon images use the static paths so icons load correctly
    (function() {
      if (typeof L !== 'undefined' && L.Icon && L.Icon.Default) {
        L.Icon.Default.mergeOptions({
          iconRetinaUrl: "{{ url_for('static', filename='vendor/leaflet/images/marker-icon-2x.png') }}",
          iconUrl: "{{ url_for('static', filename='vendor/leaflet/images/marker-icon.png') }}",
          shadowUrl: "{{ url_for('static', filename='vendor/leaflet/images/marker-shadow.png') }}"
        });
      }
    })();
  </script>

  <script>
  (function(){
    const findBtn = document.getElementById('find-nearby');
    const msgEl = document.getElementById('nearby-msg');
    const mapEl = document.getElementById('map');
    const listEl = document.getElementById('nearby-list');
    const fallbackEl = document.getElementById('nearby-fallback');
    const fallbackInput = document.getElementById('fallback-location');
    const fallbackBtn = document.getElementById('fallback-search');

    const specialistName = "{{ result.doctor_specialty | e }}";
    let map = null;
    let markersLayer = null;

    function showMessage(s){
      if (msgEl) msgEl.textContent = s;
    }

    function escapeHtml(text) {
      if (!text) return '';
      return text.replace(/[&<>"']/g, function(m){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[m]; });
    }

    // Client-side fetch with AbortController (timeout)
    async function fetchWithTimeout(resource, options = {}) {
      const { timeout = 45000 } = options;
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      try {
        const res = await fetch(resource, { ...options, signal: controller.signal });
        clearTimeout(id);
        return res;
      } catch (err) {
        clearTimeout(id);
        throw err;
      }
    }

    async function findNearbyByCoords(lat, lng) {
      showMessage('Searching nearby providers...');
      mapEl.style.display = 'block';
      try {
        const url = `/nearby?lat=${encodeURIComponent(lat)}&lng=${encodeURIComponent(lng)}&radius=3000&specialist=${encodeURIComponent(specialistName)}`;
        const res = await fetchWithTimeout(url, { timeout: 45000, cache: 'no-store' });
        if (!res.ok) {
          showMessage('Service temporarily unavailable. Please try again later.');
          return;
        }
        const j = await res.json();
        if (!j.ok) {
          showMessage('No results found or service returned an error.');
          return;
        }
        showMessage(`${j.count} places found`);
        renderPlacesOnMap(j.places, lat, lng);
      } catch (err) {
        if (err.name === 'AbortError') {
          showMessage('Request timed out. Please try again.');
        } else {
          console.error(err);
          showMessage('Network or server error. Try again later.');
        }
      }
    }

    function ensureMap(userLat, userLng) {
      if (!map) {
        map = L.map('map').setView([userLat, userLng], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19,
          attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);
        markersLayer = L.layerGroup().addTo(map);
      } else {
        // no-op; we'll clear markers later
      }
    }

    function renderPlacesOnMap(places, userLat, userLng) {
      ensureMap(userLat, userLng);
      markersLayer.clearLayers();

      // add user marker
      L.circleMarker([userLat, userLng], { radius: 6 }).addTo(markersLayer).bindPopup('You are here');

      listEl.innerHTML = '';
      if (!places || !places.length) {
        listEl.innerHTML = '<li>No nearby places found.</li>';
        return;
      }

      places.forEach(p => {
        const lat = parseFloat(p.lat), lng = parseFloat(p.lng);
        if (Number.isNaN(lat) || Number.isNaN(lng)) return;
        const marker = L.marker([lat, lng]).addTo(markersLayer);
        const popupHtml = `<strong>${escapeHtml(p.name)}</strong><br/>${escapeHtml(p.address || '')}`;
        marker.bindPopup(popupHtml);

        const li = document.createElement('li');
        li.style.cursor = 'pointer';
        li.style.marginBottom = '10px';
        li.innerHTML = `<strong>${escapeHtml(p.name)}</strong><br/><small>${escapeHtml(p.address || '')}</small><br/>
                        <a href="https://www.openstreetmap.org/directions?from=${userLat},${userLng}&to=${lat},${lng}" target="_blank" rel="noopener">Get directions</a>`;
        li.addEventListener('click', () => {
          map.setView([lat, lng], 16);
          marker.openPopup();
        });
        listEl.appendChild(li);
      });

      // fit to markers safely
      try {
        const bounds = markersLayer.getBounds();
        if (bounds && bounds.isValid && bounds.isValid()) {
          map.fitBounds(bounds.pad(0.2));
        }
      } catch (e) {
        // ignore fit errors
      }
    }

    // Improved geolocation error handler
    function geolocationErrorHandler(err) {
      console.warn('Geolocation error', err);
      if (err && err.code) {
        if (err.code === err.PERMISSION_DENIED) {
          showMessage('Location permission denied. Use the fallback search below.');
        } else if (err.code === err.POSITION_UNAVAILABLE) {
          showMessage('Location unavailable. Try again or use fallback search.');
        } else if (err.code === err.TIMEOUT) {
          showMessage('Location request timed out. Try again or use fallback.');
        } else {
          showMessage('Geolocation error occurred. Use fallback search.');
        }
      } else {
        showMessage('Geolocation failed. Use fallback search.');
      }
      fallbackEl.style.display = 'block';
    }

    // Try to automatically locate the user when the page loads.
    function tryAutoLocate() {
      if (!navigator.geolocation) {
        showMessage('Geolocation not supported; use fallback.');
        fallbackEl.style.display = 'block';
        return;
      }
      // Ask permission and attempt to get current position.
      showMessage('Attempting to detect your location automatically...');
      navigator.geolocation.getCurrentPosition(
        (pos) => { findNearbyByCoords(pos.coords.latitude, pos.coords.longitude); },
        geolocationErrorHandler,
        { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
      );
    }

    // wire up button and fallback
    findBtn && findBtn.addEventListener('click', tryAutoLocate);

    fallbackBtn && fallbackBtn.addEventListener('click', async () => {
      const q = (fallbackInput && fallbackInput.value || '').trim();
      if (!q) {
        showMessage('Enter a city or pincode to search.');
        return;
      }
      showMessage('Resolving place...');
      try {
        const r = await fetchWithTimeout(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}&limit=1`, { timeout: 30000 });
        if (!r.ok) {
          showMessage('Geocoding service error.');
          return;
        }
        const data = await r.json();
        if (data && data.length) {
          const lat = parseFloat(data[0].lat), lon = parseFloat(data[0].lon);
          findNearbyByCoords(lat, lon);
        } else {
          showMessage('Place not found. Try different input.');
        }
      } catch (e) {
        if (e.name === 'AbortError') {
          showMessage('Geocoding timed out. Try again.');
        } else {
          console.error(e);
          showMessage('Geocoding failure.');
        }
      }
    });

    // Run automatic locate after DOM loaded. If user blocks permission, fallback will be shown.
    document.addEventListener('DOMContentLoaded', function() {
      // slight delay helps browsers display permission prompt after page paint
      setTimeout(tryAutoLocate, 350);
    });

  })();
  </script>

  <style>
    /* local tweaks for the nearby UI */
    #nearby-list li { list-style: none; border-bottom: 1px solid rgba(0,0,0,0.05); padding-bottom:8px; }
    #nearby-list li a { font-size: 13px; color: var(--primary-color); text-decoration: none; }
    #nearby-list li a:hover { text-decoration: underline; }
  </style>
{% endblock %}